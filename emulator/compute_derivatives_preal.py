#!/usr/bin/env python
#
# Code to compute the derivatives of P_{real}(k) wrt
# parameters using finite difference.  These derivatives
# are stored in a JSON file allowing emulation of
# P_{real} via Taylor series.
#
import numpy as np
import sys
import json

from taylor_approximation import compute_derivatives
from compute_preal_tables import kvec


# Parse the inputs.
if len(sys.argv)<=1:
    raise RuntimeError("Usage: "+sys.argv[0]+" <basedir> [zout1 zout2 ...]")
basedir = sys.argv[1]
zs      = [float(x) for x in sys.argv[2:]]

# Remake the data grid:
order = 4
Npoints = 2*order + 1

# These are settings for OmegaM, h, sigma8
# param_str = ['omegam', 'h', 'sigma8']
#x0s = [0.31, 0.68, 0.73]
#dxs = [0.01, 0.01, 0.05]

# These are settings for OmegaM, h, lnAs
param_str = ['omegam', 'h', 'logA']
x0s = [0.31, 0.68, 2.84]
dxs = [0.01, 0.01, 0.05]

Nparams = len(x0s)
output_shape = (len(kvec),14) # first row is kv

center_ii = (order,)*Nparams
P0grid = np.zeros( (Npoints,)*Nparams+ output_shape)

# Set up the paths and create an empty dictionary.
fb      = basedir + '/data/preal/'
emu_dict= {}

# Load data per z:
for z in zs:
    # Load grid for each redshift from the pre-computed files
    # (these are generated by "build_grid_preal.py".
    for ii in range(Npoints):
        for jj in range(Npoints):
            for kk in range(Npoints):
                fn = "preal_z_{:.2f}/".format(z)
                fn+= "preal_{:d}_{:d}_{:d}.txt'.format(ii,jj,kk))
                P0grid[ii,jj,kk] = np.loadtxt(fb+fn)
    # Now compute the derivatives
    derivs0 = compute_derivatives(P0grid, dxs, center_ii, 5)
    list0   = [ dd.tolist() for dd in derivs0 ]
    # and add them to the dictionary.
    emu_dict[z] = {'params': param_str,\
                   'x0': x0s,\
                   'kvec': kvec.tolist(),\
                   'derivs': list0}

# Write the results to file.
outfile   = basedir + '/emu/preal.json'
json_file = open(outfile, 'w')
json.dump(emu_dict, json_file)
json_file.close()
#
